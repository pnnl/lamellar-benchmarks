//! Bellman-Ford algorithm; see the Bale documentation for background.
//!
//! # Testing
//!
//! This code was validated by comparing with pre-computed shortest path lengths provided from a python script.
//! At the time this documentation was written, the script was located at `lamellar_benchmarks/python/generate_geometric_graphs.py`.
//! You can reproduce the results of this valudation on a 1000 vertex graph by running
//! ```
//! LAMELLAR_THREADS=2 srun --cpus-per-task=4 --cpu-bind=ldoms,v  -N 2 --ntasks-per-node=2 -A lamellar --mpi=pmi2 --exclusive lamellar_benchmarks_repo/target/release/sssp_bellman_ford_irredundant_search --graph-type from_file --load-adjacency-matrix-from /people/roek189/learning_lamellar/lamellar_benchmarks_repo/python/geometric_graph_2d_1000v
//! ```
//! The ``lamellar_benchmarks/python` folder contains several other precomputed graphs which can be validated similarly.
//!
//! # Examples
//!
//! See the `struct Cli{ .. }` block below for description of command line arguments.
//!
//! Run one of the following from a command shell. Replace `/people/roek189/learning_lamellar/lamellar_benchmarks_repo/target/release/sssp_bellman_ford` with a path the executable.
//! ```
//! LAMELLAR_DEADLOCK_TIMEOUT=10 LAMELLAR_THREADS=4 srun --cpus-per-task=4 --cpu-bind=ldoms,v  -N 16 --ntasks-per-node=16 -A lamellar --mpi=pmi2 --exclusive /people/roek189/learning_lamellar/lamellar_benchmarks_repo/target/release/sssp_bellman_ford_irredundant_search --rows-per-thread-per-pe 10 --avg-nnz-per-row 10 --random-seed 0 --graph-type random
//! LAMELLAR_DEADLOCK_TIMEOUT=10 LAMELLAR_THREADS=1 srun --cpus-per-task=1 --cpu-bind=ldoms,v  -N 1 --ntasks-per-node=1 -A lamellar --mpi=pmi2 --exclusive /people/roek189/learning_lamellar/lamellar_benchmarks_repo/target/release/sssp_bellman_ford_irredundant_search --rows-per-thread-per-pe 10 --avg-nnz-per-row 4 --random-seed 0 --graph-type random --uniform-weights --debug
//! LAMELLAR_THREADS=2 srun --cpus-per-task=4 --cpu-bind=ldoms,v  -N 2 --ntasks-per-node=2 -A lamellar --mpi=pmi2 --exclusive lamellar_benchmarks_repo/target/release/sssp_bellman_ford_irredundant_search --graph-type from_file --load-adjacency-matrix-from /people/roek189/learning_lamellar/lamellar_benchmarks_repo/python/geometric_graph_2d_1000v
//! ```







// !!! To-do: update this to reduce unnecessary searches

















//  ---------------------------------------------------------------------------

use lamellar::active_messaging::prelude::*;
use lamellar::darc::prelude::*;

use sparse_matrix_am::matrix_constructors::{dart_uniform_rows, load_sparse_matrix, load_f64_vector_from_pickle};
use sparse_matrix_am::sssp_serial::dijkstra;
use sparse_matrix_am::formatting::format_f64_vec_as_string;

use clap::{Parser, Subcommand};
use ordered_float::OrderedFloat;
use rand::prelude::*;
use rand::seq::SliceRandom;
use sprs::{CsMat,TriMat};

use std::collections::HashMap;
use std::collections::HashSet;
use std::io;
use std::time::{Instant, Duration};

//  ---------------------------------------------------------------------------






fn main() {

    let world                   =   lamellar::LamellarWorldBuilder::new().build();    

    // command line arguments
    // -----------------    

    let cli = Cli::parse();

    let mut rows_per_thread_per_pe      =   cli.rows_per_thread_per_pe.unwrap_or(1);
    let mut rows_per_pe                 =   rows_per_thread_per_pe * world.num_threads_per_pe();
    let mut num_rows_global             =   rows_per_pe * world.num_pes();    
    let avg_nnz_per_row         		=   cli.avg_nnz_per_row.unwrap_or(1);
    let seed_matrix             		=   cli.random_seed.unwrap_or(0);  


    // if applicable, peek at adjacency matrix stored on file
    // this option applies for cases where we have a graph that was generated by a specific
    // python script and saved in a specific format. when this comment was written, the script
    // was located at: lamellar_benchmarks_repo/python/generate_geometric_graphs.py.
    // #pythonvalidation    
    let mut adjacency_matrix            =   TriMat::new((0,0));
    if let Some( file_path ) = cli.load_adjacency_matrix_from.clone() {
        let adjacency_matrix_result    	=   load_sparse_matrix( & file_path );
        if adjacency_matrix_result.is_err() {
            println!("Error: the user-provided file path:\n{:?}\n does not point to a valid adjacency matrix. See command line instructions for formatting requirements.", file_path.clone());
            return
        }
        adjacency_matrix                =   adjacency_matrix_result.unwrap();

        num_rows_global            		=   adjacency_matrix.rows();
        rows_per_pe                     =   num_rows_global / world.num_pes();
        rows_per_thread_per_pe          =   rows_per_pe     / world.num_threads_per_pe();
    }


    // initialize timer variables
    // --------------------------
    let mut time_to_initialize  =   Instant::now().duration_since(Instant::now());
    let mut time_to_loop        =   Instant::now().duration_since(Instant::now());
    let start_time_initializing_values  
                                =   Instant::now();

    // define parameters
    // -----------------

    let row_owned_first_in      =   rows_per_pe * world.my_pe();
    let row_owned_first_out     =   ( row_owned_first_in + rows_per_pe ).min( num_rows_global );
    let num_rows_owned          =   row_owned_first_out - row_owned_first_out;
    let owned_row_indices       =   (row_owned_first_in..row_owned_first_out).collect::<Vec<usize>>();         
    


    // a function to generate the slice of the weighted adjacency matrix owned by any pe
    // ---------------------------------------------------------------------------------
    let mut matrix_slice_for_pe =   | pe: usize | -> (Vec<usize>,Vec<usize>,Vec<OrderedFloat<f64>>) {
        
        // ---------------------------------------------
        // generate a cycle graph, if the cycle flag is active
        // ---------------------------------------------  
        
        let (cycle, bicycle, random) = (String::from("cycle"), String::from("bicycle"), String::from("random"));

        if cli.debug{
            println!("graph type === {:?}", cli.graph_type.clone() );
        }

        if cli.graph_type.as_str() == String::from("cycle") {
            if cli.debug{
                println!("-- cycle graph ");
            }
            let indices_row             =   owned_row_indices.clone();
            let indices_col: Vec<_>     =   indices_row // each edge has form N --> (N+1) mod (# vertices)
                                                .iter()
                                                .cloned()
                                                .map(|x| ( x + 1) % num_rows_global )
                                                .collect();
            let weights                 =   vec![ OrderedFloat(1f64); indices_row.len() ]; // all edges get weight 1
            return (indices_row, indices_col, weights)   
        }
        
        if cli.graph_type.as_str() == String::from("bicycle") {
            if cli.debug{
                println!("-- bicycle graph ");
            }            
            let x                       =   owned_row_indices.clone();
            let y: Vec<_>               =   owned_row_indices // each edge has form N --> (N+1) mod (# vertices)
                                                .iter()
                                                .cloned()
                                                .map(|x| ( x + 1) % num_rows_global )
                                                .collect();
            // connect every node to the node that precedes and follows it
            let mut indices_row         =   x.clone();
            let mut indices_col         =   y.clone();
            indices_row.extend_from_slice( & y.clone() );
            indices_col.extend_from_slice( & x.clone() );                

            let weights                 =   vec![ OrderedFloat(1f64); indices_row.len() ]; // all edges get weight 1
            return (indices_row, indices_col, weights)  
        }

        if cli.graph_type.as_str() == String::from("random") {
            if cli.debug{
                println!("-- random graph ");
            }           
            let (indices_row, indices_col)  
                                        =   dart_uniform_rows(
                                                seed_matrix + pe, // random seed
                                                num_rows_global, // number of matrix columns
                                                avg_nnz_per_row * rows_per_pe, // desired number of nonzeros
                                                & owned_row_indices, // list of row indices; a row will be generated for each index                
                                            );

            
            if cli.debug {
                // let (indices_row_0, indices_col_0)  
                //                             =   dart_uniform_rows(
                //                                     seed_matrix + pe, // random seed
                //                                     num_rows_global, // number of matrix columns
                //                                     avg_nnz_per_row * rows_per_pe, // desired number of nonzeros
                //                                     & owned_row_indices, // list of row indices; a row will be generated for each index                
                //                                 );                
                // println!("indices_col {:?}", & indices_col );
                // if indices_row != indices_row_0 {
                //     println!("");
                //     println!("!!!!!!!!! SAME INPUT DIFFERENT OUTPUT ");
                //     println!("len(output_0) = {:?}, len(utput_1) = {:?}", indices_row_0.len(), indices_row.len() );
                //     println!("{:?}", &indices_row_0);
                //     println!("{:?}", &indices_row);                    
                //     println!("");                   
                // }    
            }
                                        
            // define a random number generator
            let mut rng                 =   rand::rngs::StdRng::seed_from_u64( (seed_matrix +1) as u64 );
            // define a vector of randomly generated weights
            let weights: Vec<_>     =   
                                        match cli.uniform_weights {
                                            true    =>  { vec![ OrderedFloat(1.0); indices_col.len() ] }
                                            false   =>  {
                                                            (0..indices_col.len())
                                                                .map(|x| OrderedFloat(rng.gen::<f64>()) )
                                                                .collect()
                                                        }
                                        };
            return (indices_row, indices_col, weights) 
        }     


        if cli.graph_type.as_str() == "from_file" {
            // this option applies for cases where we have a graph that was generated by a specific
            // python script and saved in a specific format. when this comment was written, the script
            // was located at: lamellar_benchmarks_repo/python/generate_geometric_graphs.py.
            // #pythonvalidation

            let row_owned_first_in_local    =   rows_per_pe * pe;
            let row_owned_first_out_local   =   ( row_owned_first_in + rows_per_pe ).min( num_rows_global );            


            let all_row_indices         =   adjacency_matrix.row_inds();
            let all_col_indices         =   adjacency_matrix.col_inds();
            let all_data                =   adjacency_matrix.data();

            let selectors               =   ( 0 .. all_data.len() )
                                                .filter( 
                                                    |n| 
                                                    ( all_row_indices[ *n ] >= row_owned_first_in_local )
                                                    &&
                                                    ( all_row_indices[ *n ] <  row_owned_first_out_local )
                                                )
                                                .collect::<Vec<_>>();

            let indices_row             =   selectors
                                                .iter()
                                                .map( |n| all_row_indices[ *n ].clone() )
                                                .collect::<Vec<_>>();

            let indices_col             =   selectors
                                                .iter()
                                                .map( |n| all_col_indices[ *n ].clone() )
                                                .collect::<Vec<_>>();
                                                
            let weights                 =   selectors
                                                .iter()
                                                .map( 
                                                    |n| 
                                                    OrderedFloat( all_data[ *n ].clone() )
                                                )
                                                .collect::<Vec<_>>();   
                                                
            return (indices_row, indices_col, weights)                                                 
        }
        
        println!("Unrecognized graph type: using an edgeless, nodeless graph.");                                
        return (Vec::new(),Vec::new(),Vec::new())              
               
    };     
   

    // use the function to generate a matrix
    // ---------------------------------------------------------------------------------
    let (indices_row, indices_col, weights) 
                                =   matrix_slice_for_pe( world.my_pe() );    
    // let weights: Vec<_>         =   weights.into_iter().map(|x| OrderedFloat(x)).collect();

    let num_entries             =   indices_row.len();
    let matrix                  =   TriMat::from_triplets(
                                        (num_rows_global,num_rows_global),
                                        indices_row.clone(),  // <------------------------------------- !!!!!!!!!!!!!!!!!!!!!!!!!!! WHEN WE CALL TriMat::from_triplets WE REVERSE ROWS AND COLUMNS, ESSENTIALLY TRANSPOSING THE MATIRX
                                        indices_col.clone(),
                                        weights, 
                                    );
    let matrix                  =   matrix.to_csr::<usize>();

    if cli.debug {
        println!("----------------------------------------------------");
        println!("Edges       (PE{:?})", world.my_pe() );
        println!("----------------------------------------------------");
        let mut edges: Vec<_> = matrix.iter().map(|(v,(i,j))| (j,i,v.clone())).collect();
        edges.sort();
        for edge in edges { println!("{:?}", edge ); }
    }

    // the number and sum-of-column-indices of the nonzero entries in each row
    let mut tentative_scores    =   vec![ OrderedFloat(f64::INFINITY); num_rows_global ];
    tentative_scores[0]         =   OrderedFloat(0.0); // the base node has weight 0


    // wrap in LocalRwDarc's
    let tentative_scores        =   LocalRwDarc::new( world.team(), tentative_scores        ).unwrap();
    let scores_have_changed     =   LocalRwDarc::new( world.team(), false                   ).unwrap();
    
    time_to_initialize          =   Instant::now().duration_since(start_time_initializing_values); 


    // enter loop
    // -----------------

    let start_time_main_loop    =   Instant::now();   
    let mut num_epochs_total    =   0; 

    for epoch in 0..num_rows_global {

        **world.block_on(scores_have_changed.write())               =   false; // update our flag

        // Step 1: check to see if any scores can be reduced by relaxing edges
        let (new_scores, updating_edges) = {

            let mut new_scores                      =   Vec::new();
            let mut updating_edges                  =   HashMap::new(); // !!!!!!!! DELETE AFTER DEBUGGING
            let mut tentative_scores_temp           =   world.block_on(tentative_scores.write());
            let mut tentative_scores_frozen: Vec<_> =   tentative_scores_temp.iter().cloned().collect(); // !!!!! DELETE AFTER DEBUGGING
            
            for row in row_owned_first_in .. row_owned_first_out {

                let mut tentative_score             =   tentative_scores_temp[ row ].clone();
                let mut source_vertex               =   None;

                // relax each edge in this row
                for ( col, weight ) in matrix.outer_view( row ).unwrap().iter() {
                    let candidate_value             =   tentative_scores_frozen[ col ] + weight;
                    if candidate_value < tentative_score {
                        tentative_score             =   candidate_value;
                        source_vertex               =   Some( col ); // !!!!!!! DELETE AFTER DEBUGGING
                    }
                }
                if tentative_score < tentative_scores_temp[ row ] {
                    new_scores.push( (row, tentative_score.into_inner()) ); // push the (vertex,value) pair to a list that will broadcast to all the nodes
                    tentative_scores_temp[ row ]    =   tentative_score; // update the local score

                    let source                      =   source_vertex.unwrap();
                    updating_edges.insert( row, (source,row,tentative_score) );
                }
            }

            world.barrier();
        
            ( new_scores, updating_edges )
        };

        //  Step 1.5: Print out the updating edges and weights
        if cli.debug{        
            println!("----------------------------------------------------");
            println!("Edges used to update vertex scores on iteration {:?}       (PE{:?})", epoch, world.my_pe() );
            println!("----------------------------------------------------");
            let mut edges: Vec<_>       =   updating_edges.values().cloned().collect();
            edges.sort();
            for (source, target, new_vertex_score) in edges {
                println!("Edge: {:?}  Vertex score: {:?}", (source,target), new_vertex_score );
            }
        }
    

        //  Step 2: if necessary, broadcast the updated vertex scores
        if ! new_scores.is_empty() {
            let am  =   UpdateScoresAm{
                            new_scores:             new_scores,
                            receives_new_scores:    tentative_scores.clone(),
                            scores_have_changed:    scores_have_changed.clone()
                        };
            let _   =   world.exec_am_all( am );
        }

        world.wait_all();          
        world.barrier();             


        if ! **world.block_on(scores_have_changed.read()) {
            num_epochs_total    =   epoch;

            if cli.debug {
                let distances: Vec< f64 >
                                            =   (*world.block_on(tentative_scores.read()))
                                                    .clone()
                                                    .into_iter()
                                                    .map(|x| x.into_inner() )
                                                    .collect(); 
                           
                println!("----------------------------------------------------");
                println!("Final vertex scores");
                println!("----------------------------------------------------");
                for (vertex, score) in distances.iter().enumerate() {
                    println!("{:?}     {:?}", vertex, score );
                }
            }             

            break
        }        
    }

    
    // finished -- report results
    // --------------------------------    


    let tentative_distances_pe_0: Vec< f64 >
                                =   (*world.block_on(tentative_scores.read()))
                                        .clone()
                                        .into_iter()
                                        .take( rows_per_pe )
                                        .map(|of| of.into_inner())
                                        .collect();
    let max_path_length_pe_0    =   tentative_distances_pe_0.iter().cloned().map(|x| OrderedFloat(x) ).max().unwrap();

    
    if world.my_pe() == 0 {

        time_to_loop            =   Instant::now().duration_since(start_time_main_loop);   
        
        
        // if we loaded the graph from a file generated by our python script, then verify that the
        // shortest path we compute equals the shortest path computed by python #pythonvalidation
        if let Some( file_path ) = cli.load_adjacency_matrix_from {
            let true_shortest_path_lengths      =   load_f64_vector_from_pickle( & ( file_path.clone() + "/shortest_path_lengths.pkl" ) );
            if true_shortest_path_lengths.is_ok() {
                let true_shortest_path_lengths  =   true_shortest_path_lengths.unwrap();
                assert_eq!( true_shortest_path_lengths[ 0 .. rows_per_pe ], tentative_distances_pe_0  )
            }
        }        

        if cli.write_to_json {

            println!("");
            println!("WRITING TO JSON!!!!!!!!!!!!!!!!!!!!!!!");
            println!("");

            // write the calculated path lengths to json
            // -----------------------------------------
            write_to_json_file("sssp_unit_test_data_bellman_ford_irredundant_search.json", &tentative_distances_pe_0[..rows_per_pe] );


            // a function to generate the slice of the weighted adjacency matrix owned by any pe
            // ---------------------------------------------------------------------------------
            let matrix_slice_for_pe     =   | pe: usize | -> (Vec<usize>,Vec<usize>,Vec<f64>) {
                // calculate which rows are owned by this pe
                let row_owned_first_in      =   rows_per_pe * pe;
                let row_owned_first_out     =   ( row_owned_first_in + rows_per_pe ).min( num_rows_global );
                let num_rows_owned          =   row_owned_first_out - row_owned_first_out;                
                let owned_row_indices       =   (row_owned_first_in..row_owned_first_out).collect::<Vec<usize>>();
                // 
                let (indices_row, indices_col)  
                                            =   dart_uniform_rows(
                                                    seed_matrix + pe, // random seed
                                                    num_rows_global, // number of matrix columns
                                                    avg_nnz_per_row * rows_per_pe, // desired number of nonzeros
                                                    & owned_row_indices, // list of row indices; a row will be generated for each index                
                                                );

                // let (indices_row_0, indices_col_0)  
                //                             =   dart_uniform_rows(
                //                                     seed_matrix + pe, // random seed
                //                                     num_rows_global, // number of matrix columns
                //                                     avg_nnz_per_row * rows_per_pe, // desired number of nonzeros
                //                                     & owned_row_indices, // list of row indices; a row will be generated for each index                
                //                                 );
                // println!("indices_col {:?}", & indices_col );
                // if indices_row != indices_row_0 {
                //     println!("");
                //     println!("!!!!!!!!! SAME INPUT DIFFERENT OUTPUT ");
                //     println!("len(output_0) = {:?}, len(utput_1) = {:?}", indices_row_0.len(), indices_row.len() );
                //     println!("{:?}", &indices_row_0);
                //     println!("{:?}", &indices_row);                    
                //     println!("");                   
                // }  

                // define a random number generator
                let mut rng                 =   rand::rngs::StdRng::seed_from_u64( (seed_matrix +1) as u64 );
                // define a vector of randomly generated weights
                let weights: Vec<_>         =   (0..indices_col.len())
                                                    .map(|x| rng.gen::<f64>() )
                                                    .collect();
                return (indices_row, indices_col, weights)              
            };

            // write the full adjacency matrix to json
            // ---------------------------------------            
            let mut indices_row         =   Vec::new();
            let mut indices_col         =   Vec::new();  
            let mut weights             =   Vec::new();           
            for pe in 0 .. world.num_pes() {
                let (mut ir, mut ic, mut w)           =   matrix_slice_for_pe( pe );
                indices_row.append( &mut ir );
                indices_col.append( &mut ic );
                weights.append( &mut w );
            }
            indices_row.append( &mut indices_col );
            write_to_json_file("sssp_unit_test_matrix_bellman_ford_irredundant_search.json", &indices_row );
            write_to_json_file("sssp_unit_test_weight_bellman_ford_irredundant_search.json", &weights );           

        }            

        println!("");
        println!("Finished successfully");
        println!("");

        println!("Number of PE's:                     {:?}", world.num_pes() );  
        println!("Cores per PE:                       {:?}", world.num_threads_per_pe());        
        println!("Matrix size:                        {:?}", num_rows_global );
        println!("Rows per thread per PE:             {:?}", rows_per_thread_per_pe );        
        println!("Avg nnz per row:                    {:?}", matrix.nnz() as f64 / rows_per_pe as f64 );
        println!("Random seed:                        {:?}", cli.random_seed );
        println!("");          
        println!("Number of epochs:                   {:?}", num_epochs_total );
        println!("Maximum path length (PE 0):         {:?}", max_path_length_pe_0 );        
        println!("");
        println!("Time to initialize matrix:          {:?}", time_to_initialize );
        println!("Time to get shortest paths:         {:?}", time_to_loop );
        println!("");

        println!("");
        println!("{:?}", time_to_loop.as_secs() as f64 + time_to_loop.subsec_nanos() as f64 * 1e-9); // we add this extra line at the end so we can feed the run time into a bash script, if desired                                   

    }
}



//  ===========================================================================
//  ACTIVE MESSAGE
//  ===========================================================================



/// Allows each node to send updated scores to the other PE's
#[lamellar::AmData(Debug, Clone)]
pub struct UpdateScoresAm {
    pub new_scores:             Vec< (usize, f64) >,            // a collection of new vertex scores
    pub receives_new_scores:    LocalRwDarc< Vec< OrderedFloat<f64> > >,   // the score ledger we want to update with the new scores
    pub scores_have_changed:    LocalRwDarc< bool >,                  // flag to track whether any scores have changed
}

#[lamellar::am]
impl LamellarAM for UpdateScoresAm {
    async fn exec(self) {        
        let mut receives_new_scores         =   self.receives_new_scores.write().await; // get a writable handle on the local collection of diagonal elements
        let mut scores_have_changed         =   self.scores_have_changed.write().await;
        **scores_have_changed               =   true; // mark that at least one score has changed
        for ( vertex, score ) in self.new_scores.iter() {
            receives_new_scores[ *vertex ]  =   OrderedFloat( * score );
        }
    }
}



//  ===========================================================================
//  WRITE OUTPUT TO JSON (OPTIONALLY)
//  ===========================================================================



use serde_json::to_writer;
use serde::ser::Serialize;
use std::env;
use std::fs::File;

fn write_to_json_file< T >(filename: &str, data: &[T]) 
    where 
        T:  Sized + Serialize
{
    // Get the current directory
    let current_dir = env::current_dir().unwrap();

    // Construct the path to the JSON file relative to the current directory
    let file_path = current_dir.join(filename);

    // Create a new file at the specified path
    let file = File::create(file_path).unwrap();

    // Serialize the data to JSON and write it to the file
    to_writer(file, data).unwrap();
}



//  ===========================================================================
//  COMMAND LINE INTERFACE
//  ===========================================================================



#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// The number of rows owned by each PE
    #[arg(short, long, )]
    rows_per_thread_per_pe: Option<usize>,

    /// Desired average number of nonzero entries per row
    #[arg(short, long, )]
    avg_nnz_per_row: Option<usize>,

    /// Turn debugging information on
    #[arg(short, long, )]
    random_seed: Option<usize>,

    /// If true, then write the first 1000 weights to a .json file
    #[arg(short, long, )]
    write_to_json: bool,  
    
    /// Determines the type of graph generated; can be 'cycle' (for a directed cycle), 'bicycle' (for a directed cycle where we add, for each edge, an edge in the opposite direction), and 'random' (for a "dart-style" Erdos-Renyi random graph)
    #[arg(short, long, )]
    graph_type: String,      

    /// If true, then print debugging information
    #[arg(short, long, )]
    debug: bool,          

    /// File path to adjacency matrix
    ///
    /// This option applies for cases where we have a graph that was generated by a specific
    /// python script and saved in a specific format. when this comment was written, the script
    /// was located at: lamellar_benchmarks_repo/python/generate_geometric_graphs.py.
    /// #pythonvalidation    
    #[arg(short, long, )]
    load_adjacency_matrix_from: Option< String >,           

    /// If true, then all edge weights are set to 1
    #[arg(short, long, )]
    uniform_weights: bool,              
}




//  ===========================================================================
//  PERFORMANCE
//  ===========================================================================


// Number of PE's:                     4
// Cores per PE:                       2
// Matrix size:                        400000
// Rows per PE:                        100000
// Avg nnz per row:                    10.0
// Random seed:                        0

// Time to initialize matrix:          164.042262ms
// Time to get shortest paths:         118.044479ms